## 多任务系统

操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以**进程**的方式运行在比操作系统权限更低的级别，**每个进程都有自己独立的地址空间**，使得进程之间的地址空间相互隔离。CPU由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到CPU，但是如果运行时间超出了一定的时间，**操作系统**会暂停该进程，将CPU资源分配给其他等待运行的进程，这种CPU的分配方式即所谓的抢占式，操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要的进程。**如果OS分配给每个进程的时间都很短，即CPU在多个进程间快速切换，从而造成了很多进程都在同时运行的假象**。

## 内核进程调度算法

schedule就是主调度器的工作函数, **在内核中的许多地方, 如果要将CPU分配给与当前活动进程不同的另一个进程, 都会直接调用主调度器函数schedule或者其子函数__schedule**。

内核调度器的总体流程：即为

1. 完成一些必要的检查, 并设置进程状态, 处理进程所在的就绪队列
2. 选择合适的调度策略选出下一个需要被调度的进程任务，
3. 然后进行一次上下文切换，将进程置为运行态。

> 首先，我们需要清楚，什么样的进程会进入调度器进行选择，就是处于TASK_RUNNING状态的进程，而其他状态下的进程都不会进入调度器进行调度。
> **系统发生调度的时机如下**
>
> - 调用cond_resched()时
> - 显式调用schedule()时
> - 从系统调用或者异常中断返回用户空间时
> - 从中断上下文返回用户空间时
>
> 当开启内核抢占(默认开启)时，会多出几个调度时机，如下
>
> - 在系统调用或者异常中断上下文中调用preempt_enable()时(多次调用preempt_enable()时，系统只会在最后一次调用时会调度)
>
> - 在中断上下文中，从中断处理函数返回到可抢占的上下文时(这里是中断下半部，中断上半部实际上会关中断，而新的中断只会被登记，由于上半部处理很快，上半部处理完成后才会执行新的中断信号，这样就形成了中断可重入)
>
> 而**在系统启动调度器初始化时会初始化一个调度定时器，调度定时器每隔一定时间执行一个中断，在中断会对当前运行进程运行时间进行更新，如果进程需要被调度，在调度定时器中断中会设置一个调度标志位**，之后从定时器中断返回，因为上面已经提到**从中断上下文返回时是有调度时机的**，在内核源码的汇编代码中所有中断返回处理都必须去判断调度标志位是否设置，如设置则执行schedule()进行调度。
>
> 而我们知道实时进程和普通进程是共存的，调度器是怎么协调它们之间的调度的呢，其实很简单，每次调度时，会先在实时进程运行队列中查看是否有可运行的实时进程，如果没有，再去普通进程运行队列找下一个可运行的普通进程，如果也没有，则调度器会使用idle进程进行运行。
>
> 系统并不是每时每刻都允许调度的发生，当处于硬中断期间的时候，调度是被系统禁止的，之后硬中断过后才重新允许调度。而对于异常，系统并不会禁止调度，也就是在异常上下文中，系统是有可能发生调度的。



### CPS完全公平调度



## 进程

### 进程内核栈

> 为什么需要单独的进程内核栈？
>
> - 所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 `schedule()` 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了；

## 参考

- [Linux进程调度器概述--Linux进程的管理与调度](https://blog.csdn.net/gatieme/article/details/51699889)


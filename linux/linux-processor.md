## Linux进程栈

> 内核就是一个由interrupt驱动的程序。这个interrupt可以是一个系统调用（x86下，很多OS的系统调用是靠software interrupt实现的），可以是一个用户程序产生的异常，也可以是一个硬件产生的事件中断。
>
> 于是你的问题解决了：一个用户程序运行的时候，Linux就在内存里呆着，等着一个中断的到来。**在这个中断的处理过程中，来做“调度”。**而一般的时分系统里，都会有个timer interrupt每隔一段时间到来，也就是楼上说的“时间片”。

> 最基础的调度是用时钟中断搞的，每隔若干时间，外面的芯片就会给 cpu 发个时钟中断 int 20h，此时操作系统（更具体而言是一个中断处理程序）拦截这个中断，保存当前 cpu 状态（寄存器、页表，等等），把另一个进程保存的状态恢复进去，然后结束中断，切换进程。
> 软件调用操作系统的功能也是用中断（软中断），linux 底下（曾经）是 int 80h，现在用 sysenter。



## 进程的内核栈和用户栈

> 内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，**cpu堆栈指针寄存器**里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。
>
> **内核栈**是属于操作系统空间的一块固定区域，可以用于保存中断现场、保存操作系统子程序间相互调用的参数、返回值等。
>
> **用户栈**是属于用户进程空间的一块区域，用户保存用户进程子程序间的相互调用的参数、返回值等。

## 内核栈和用户栈的切换

> 当进程因为中断或者系统调用而陷入内核态之行时，进程所使用的堆栈也要从用户栈转到内核栈。进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态之行时，在内核态之行的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。
>
> 那么，我们知道**从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，我们是如何知道内核栈的地址的呢**？关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为，当进程在用户态运行时，使用的是用户栈，当进程陷入到内核态时，内核栈保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。
>
> ##### 为何要设置两个不同的栈?
>
> 共享原因：内核的代码和数据是为所有的进程共享的，如果不为每一个进程设置对应的内核栈，那么就不能实现不同的进程执行不同的代码。
>
> 安全原因：如果只有一个栈，那么用户就可以修改栈内容来突破内核安全保护。



## 参考

- [进程内核栈、用户栈](https://blog.csdn.net/jasonLee_lijiaqi/article/details/80181501)


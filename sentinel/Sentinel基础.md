# Sentinel基础

## 流控

## 流控设置项

### 资源名

默认的是请求路径，当然不一定是路径，只要是唯一的名称就行

### 针对来源

针对调用同一个资源时，Sentinel是能够区分不同调用者，为不同的调用者设置不一样的流控规则；如：app-a设置QPS类型的流控，app-b设置线程数类型的流控。默认default，表示不区分调用者

### 阈值类型

#### QPS：当调用这个api的时，QPS达到单机阈值时，就会限流

#### 线程：当调用这个api的时，线程数达到单机阈值时，就会限流

### 流控模式

#### 直接：达到设置的阈值，直接限流

#### 关联：当关联的资源达到阀值，就限流自己

>我们现在有两个接口/test-a，/test-b；现在我们修改一下之前的流控规格，设置一个关联。/test-b设置了关联资源为/test-a，设置的效果就是当关联资源/test-a的qps阀值超过1时，就限流/test-b接口。
>
>实际场景：我们举个例子，订单服务中会有2个重要的接口，一个是读取订单信息接口，一个是写入订单信息接口。
>
>在高并发业务场景中，两个接口都会占用资源，如果读取接口访问过大，就会影响写入接口的性能。业务中如果我们希望写入订单比较重要，要优先考虑写入订单接口。那就可以利用关联模式；**在关联资源上面设置写入接口，资源名设置读取接口就行了；这样就起到了优先写入，一旦写入请求多，就限制读的请求。**
>
>**关联模式的核心就是保护关联资源的。**

#### 链路

让/test-a和/test-b都调用这个相同的第三个test-c服务；那我们就可以利用链路模式设置限制哪个入口的流量了: 可以通过配置test-c的入口资源为test-a, 这样当请求接口/test-a调用test-c，会进行流量控制；但/test-b则不会。

>**针对来源**方式是微服务级别的，**链路模式的入口资源**是针对方法接口的。

### 流控效果

#### 快速失败：流量达到阀值，直接返回报异常

#### Warm Up：预热，根据codeFactor（默认3）的值，从（阀值/codeFactor）为初始阀值，经过预热时长，才到达设置的QPS的阀值

> 预热的应用场景，如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值。

#### 排队等待：匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效。

> 排队的应用场景是什么呢？
>
> 比如有时候系统在某一个时刻会出现大流量，之后流量就恢复稳定，可以采用这种排队模式，大流量来时可以让流量请求先排队，等恢复了在慢慢进行处理


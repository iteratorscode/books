# 《微服务》读书笔记

## 1.1 什么是微服务

**微服务是一些协同工作的小而自治的服务。**

### 1.1.1 很小、专注于做好一件事

**根据业务的边界来确定服务的边界**，这样就很容易确定某个功能代码应该放在哪里。而且由于改服务专注于某个边界之内，因此可以很好的避免由于代码过大衍生出很多相关问题。

> Rober C. Martin：单一职责
>
> 把因相同原因而变化的东西聚合到一起，而把因不同原因而变化的东西分离开来，注重服务的内聚性。

### 1.1.2 自治性

一个微服务就是一个独立的实体。他可以独立地部署在PAAS上，也可以作为操作系统的一个进程存在。我们要尽量避免把多个微服务部署到同一台机器上。

服务之间通过网络调用通信，从而加强了服务之间的隔离性，避免紧耦合。服务会暴露API，让偶服务之间通过这些API进行通信。API的实现技术应该避免与消费方耦合，这就意味着应该选择与具体技术不想关 的API实现方式，以保证技术的选择不受限制。

## 1.2 主要好处

### 1.2.1 技术异构性

在一个由多个服务相互协作的系统中，可以在不同服务中使用最适合改服务的技术。如果系统中的一部分需要做性能提升，可以使用性能更好的技术栈重新构建该部分。

### 1.2.2 弹性

对于单体系统，可以通过将同样的实例运行在不同的机器上来降低功能完全不可用的概率，然而微服务系统自身就能过很好的处理服务不可用和功能降级问题。

### 1.2.3 扩展

庞大的单块服务需要对整体进行扩展。然而使用较小的服务，则可以对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在更小的、性能稍差的硬件上。

### 1.2.4 简化部署

微服务中可以快速的对特定部分代码就行部署，如果真的出了问题，也只会影响一个服务，并且容易快速回滚，这也意味着客户可以更快的使用我们开发的新功能。

### 1.2.5 与组织架构相匹配

微服务架构可以很好的将架构和组织相匹配，避免出现过大的代码库，从而获得理想的团队大小及生产力。

### 1.2.6 可组合性

微服务系统中，根据不同的目的，人们可以通过不同的方式使用相同的功能

### 1.2.7 对可替代性的优化

在微服务系统中，重新实现某一个服务或者是直接删除该服务都是相对可操作的

## 2 演进式架构师应该承担的职责

### 2.1 愿景

确保在系统级有一个经过充分沟通的技术愿景，这个愿景应该可以帮助你满足客户和组织的需求

### 2.2 同理心

理解你所做的决定对客户和同事带来的影响

### 2.3 合作

和尽量多的同事进行沟通，从而更好地对愿景进行定义、修改和执行

### 2.4 适应性

确保在你的客户和组织需要的时候调整技术愿景

### 2.5 自治性

在标准化和团队自治之间寻找一个正确的平衡点

### 2.6 治理

确保系统按照技术愿景的要求实现

> 演进式架构师应该理解，成功要靠不断地取舍来实现。总会存在一些原因需要你改变工作的方式，但是具体做哪些改变只能依赖于自己的经验了。而僵化地固守自己的想法无疑是最糟糕的做法。

## 3 如何构建服务

让我们带着对架构师的全新认识来考虑如何寻找微服务之间正确的边界

### 3.2 什么样的服务是好的服务

**松耦合和高内聚**

### 3.2.1 松耦合

*如果做到了服务之间的松耦合，那么修改一个服务就不需要修改另一个服务。*

一个松耦合的服务应该尽可能很少的知道与之协作的那些服务的信息。这也意味着，应该限制两个服务之间不同调用形式的数量，因为除了潜在的性能问题之外，过度的通信可能会导致紧耦合。

### 3.2.2 高内聚

*我们希望把相关的行为聚集到一起，把不相关的行为放到别处*。为什么呢？因为如果你要改变某个行为的话，最好能够只在一个地方进行修改，然后就可以尽快地发布。如过需要在很多不同的地方做这些修改，那么可能就需要同时发布多个微服务才能交付这个功能。在多个不同的地方进行修改会很慢，同时部署多个服务风险也很高，这两者都是我们想要避免的。

## 3.3 限界上下文

> 任何一个给定的领域中都包含多个限界上下文，每个限界上下文中的东西分成两部分，一部分不需要与外部通信，另一部分则需要。每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他的上下文。
>
> 对于限界上下文的比喻，Evans采用了细胞膜。“细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。”。如果你想从限界上下文中获取信息，或者向其发起请求，需要使用模型和它显式边界进行通信。

### 3.3.1 共享的隐藏模型

多个上下文之间共享的模型。我们不需要把某个上下文中的所有内容都暴露出去，也就是说，对于该模型来说，存在内部和外部两种表示方式。

明白应该共享特定的模型，而不应该共享内部表示这个道理之后，就可以避免潜在的紧耦合（即我们不希望成为的样子）风险。我们还识别出了领域内的一些边界，边界内部是相关性比较高的业务功能，从而得到高内聚。这些限界上下文可以很好地形成组合边界。

### 3.3.2 模块和服务

在同一个进程内使用模块来减少彼此之间的耦合也是一种选择。刚开始开发一个代码库的时候，这可能就是比较好的办法。所以一旦你发现了领域内部的限界上下文，一定要使用模块对其进行建模，同时使用共享和隐藏模型。这些模块边界就可以成为绝佳的微服务候选。一般来讲，微服务应该清晰的和限界上下文保持一致。

### 3.3.3 过早划分

过早将一个系统划分为微服务的代价非常高，尤其是在面对新领域时。很多时候，将一个已有的代码库划分成微服务，要比从头开始构建微服务简单的多。

## 3.4 业务功能

当你在思考组织内的限界上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。

## 3.5 逐步划分上下文

一开始识别出一些粗力度的限界上下文，而这些限界上下文可能又包含一些嵌套的限界上下文。通常会有两种做法

1. 考虑微服务边界时，首先考虑大的、粗粒度的那些上下文，然后当发现合适的缝隙后，再进一步划分出那些嵌套上下文
2. 直接使这种嵌套的上下文不直接对外可见，对外界来说，他们使用的还是粗粒度的上下文提供的功能，但发出的请求其实被透明地映射到了两个或者更多的服务上

通常很难说哪种规则处理更合理，但是你应该根据组织结构来决定，到底是使用嵌套的方法还是完全分离的方法。如果完全由一个团队来管理的，那么嵌套式结构会更合理。

